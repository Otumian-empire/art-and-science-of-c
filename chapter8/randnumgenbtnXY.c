/*
randnumgenbtnXY.c 
created on Sunday, 2019, 07 July
By Otumian
*/

/*
implementing a general function that generates a random number between ranges
*/

#include <stdio.h>
#include <stdlib.h>

// prototype
// randomNumber takes 2 unsigned int args AND returns an unsigned int value.
unsigned int randomNumber(unsigned int lower, unsigned int higher);

int main()
{
    int i = 0;

    for (i; i < 50; i++)
    {
        printf("random number %d = %u\n", i, randomNumber(1, 2));
    }

    return 0;
}

// implementation
unsigned int randomNumber(unsigned int lower, unsigned int higher)
{
    /*
    Let Lc = 0, which is the least value that rand() would generate
    Let Hc = RAND_MAX (INT_MAX), which is the most value that rand() would generate
    Let our lower and uppper be L and H respectively
    Let r = rand() % H, the value generated by (rand() % H) , i.e rand() mod H
    It will be that, for all r, Lc <= r < H

    ********************************************************************************
    Initial assumption:
    If L = Lc and H = ~H (H varies), L <= (r + 1) <= H, will hold
    But if L = ~L (L varies), there exits, r < L and (r + 1) < L
    Then L <= (r + 1) <= H, will not hold
    A quick solution is to let, r = L OR (r + 1) = L
    This works fine as it is since r <= H OR (r + 1) <= H And r => L OR (r + 1) >= L
    ********************************************************************************

    ********************************************************************************
    Generalizing the above assumption:
    What if L = ~L (L varies i.e Lc <= L < H) then, L <= (r + 1) <= H should also hold
    But what if r < L or (r + 1) < L then, L <= (r + 1) <= H wouldn't hold

    ********************************************************************************
    * We could assign do (r + 1) = L, whenever (r + 1) < L.                     
    * ******************************************************************************

    unsigned int rand_val = (rand() % higher) + 1;
    unsigned int rand_num = rand_val < lower ? lower : rand_val;

    return rand_num;

    ********************************************************************************
    * We could say (r + 1) = 2L - H, whenever (r + 1) < L
    * Examining H - L > L - (r + 1) and H - L < L - (r + 1)
    * For all (r + 1) > 2L - H OR (r + 1) < 2L - H, is when (r + 1) +/- n
    * Where n is a constant
    * This works fine when (H - L) > 1
    * If the (H - L) <= 0, especially when (H - L) = 1, it means we are testing 
    * for only two choices, head or tail, 1 or 0, etc
    ********************************************************************************

    ********************************************************************************
    * The stepts below is inaccurate
    
    unsigned int rand_num, rand_val, average;

    rand_val = (rand() % higher) + 1;
    average = ((higher - lower) / 2);

    if (rand_val < lower)
    {
        if ((higher - lower) > (lower - rand_val))
        {
            rand_num = ((2 * lower) - higher) - average;
        }
        else
        {
            rand_num = ((2 * lower) - higher) + average;
        }
    }
    else
    {
        rand_num = rand_val;
    }

    return rand_num;
    *******************************************************************************
    

    *********************************************************************************
    * What if we make up a condition as in, the random number should be greater than
    * than or equal to lower
    * while ((r + 1) >= lower) {do-something}
    * and this actually did it
    ********************************************************************************/
    unsigned int rand_val;

    rand_val = (rand() % higher) + 1;

    while (rand_val < lower || rand_val > higher)
    {
        rand_val = (rand() % higher) + 1;
    }
    
    return rand_val;
}
